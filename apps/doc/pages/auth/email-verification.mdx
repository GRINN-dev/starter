```sql
create trigger _900_send_verification_email
  after insert on publ.user_emails
  for each row
  when (NEW.is_verified is false)
  execute procedure priv.tg__add_job('user_emails__send_verification');
```

```ts
import { Task } from "graphile-worker";

import { SendEmailPayload } from "./send_email";

// At least 3 minutes between resending email verifications
const MIN_INTERVAL = 1000 * 60 * 3;

interface UserEmailsSendVerificationPayload {
  id: string;
}

const task: Task = async (inPayload, { addJob, withPgClient }) => {
  const payload: UserEmailsSendVerificationPayload = inPayload as any;
  const { id: userEmailId } = payload;
  const {
    rows: [userEmail],
  } = await withPgClient((pgClient) =>
    pgClient.query(
      `
        select user_emails.id, email, verification_token, firstname, lastname, extract(epoch from now()) - extract(epoch from verification_email_sent_at) as seconds_since_verification_sent
        from publ.user_emails
        inner join priv.user_email_secrets
        on user_email_secrets.user_email_id = user_emails.id
        inner join publ.users
        on users.id = user_emails.user_id
        where user_emails.id = $1
        and user_emails.is_verified is false
      `,
      [userEmailId]
    )
  );
  if (!userEmail) {
    console.warn(
      `user_emails__send_verification task for non-existent userEmail ignored (userEmailId = ${userEmailId})`
    );
    // No longer relevant
    return;
  }
  const {
    email,
    verification_token,
    firstname,
    lastname,
    seconds_since_verification_sent,
  } = userEmail;
  if (
    seconds_since_verification_sent != null &&
    seconds_since_verification_sent < MIN_INTERVAL / 1000
  ) {
    console.log("Email sent too recently");
    return;
  }
  const sendEmailPayload: SendEmailPayload = {
    options: {
      to: email,
      subject: "Please verify your email address",
    },
    template: "verify_email.mjml",
    variables: {
      token: verification_token,
      verifyLink: `${process.env.ROOT_URL}/verify?id=${encodeURIComponent(
        String(userEmailId)
      )}&token=${encodeURIComponent(verification_token)}`,
      firstname,
      lastname,
      name,
    },
  };
  await addJob("send_email", sendEmailPayload);
  await withPgClient((pgClient) =>
    pgClient.query(
      "update priv.user_email_secrets set verification_email_sent_at = now() where user_email_id = $1",
      [userEmailId]
    )
  );
};

export default task;
```

```sql
create function publ.verify_email(user_email_id uuid, token text) returns boolean as $$
begin
  update publ.user_emails
  set
    is_verified = true,
    is_primary = is_primary or not exists(
      select 1 from publ.user_emails other_email where other_email.user_id = user_emails.user_id and other_email.is_primary is true
    )
  where id = user_email_id
  and exists(
    select 1 from priv.user_email_secrets where user_email_secrets.user_email_id = user_emails.id and verification_token = token
  );
  return found;
end;
$$ language plpgsql strict volatile security definer set search_path to pg_catalog, public, pg_temp;
comment on function publ.verify_email(user_email_id uuid, token text) is
  E'Once you have received a verification token for your email, you may call this mutation with that token to make your email verified.';

/*
 * When the users first email address is verified we will mark their account as
 * verified, which can unlock additional features that were gated behind an
 * `isVerified` check.
 */

create function publ.tg_user_emails__verify_account_on_verified() returns trigger as $$
begin
  update publ.users set is_verified = true where id = new.user_id and is_verified is false;
  return new;
end;
$$ language plpgsql strict volatile security definer set search_path to pg_catalog, public, pg_temp;

create trigger _500_verify_account_on_verified
  after insert or update of is_verified
  on publ.user_emails
  for each row
  when (new.is_verified is true)
  execute procedure publ.tg_user_emails__verify_account_on_verified();
```
